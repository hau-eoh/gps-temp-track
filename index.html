<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS Tracker - History Mode</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #map { height: 100vh; width: 100%; }

        /* Info Box Style */
        .info-box {
            padding: 15px; background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 4px 20px rgba(0,0,0,0.2); border-radius: 10px;
            min-width: 180px; border: 1px solid #f0f0f0;
            position: absolute; top: 10px; right: 10px; z-index: 1000;
        }
        .info-title {
            font-weight: 800; color: #333; margin-bottom: 12px; 
            border-bottom: 2px solid #1890ff; padding-bottom: 5px;
            text-align: center; text-transform: uppercase; font-size: 12px;
        }
        .info-item { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; color: #555; }
        .info-value { font-weight: bold; font-family: monospace; font-size: 15px; color: #222; }
        .info-footer { margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee; font-size: 11px; color: #aaa; text-align: right; }

        /* Marker Icon */
        .custom-div-icon { background: transparent; border: none; }
        .marker-pin {
            width: 48px; height: 48px; display: flex; justify-content: center; align-items: center;
            filter: drop-shadow(0px 3px 6px rgba(0,0,0,0.4)); transition: transform 0.3s;
        }
    </style>
</head>
<body>

<div id="map"></div>

<script src="https://www.unpkg.com/@eohjsc/era-widget@1.1.3/src/index.js"></script>

<script>
    // --- C·∫§U H√åNH ---
    const HISTORY_HOURS = 24; // L·∫•y d·ªØ li·ªáu 24 gi·ªù tr∆∞·ªõc
    
    const eraWidget = new EraWidget();
    let configJSON, configBUTTON;
    
    // D·ªØ li·ªáu
    let LAT = 0.0, LON = 0.0, SPEED = 0.0, ALT = 0.0, TEMP = 0.0, SATS = 0;
    let BUTTON = 0;
    let isHistoryLoaded = false; // C·ªù ki·ªÉm tra ƒë√£ load history ch∆∞a

    // Map vars
    let map, marker, infoControl, currentPath, currentColor;
    let pathCoordinates = [], lastPosition = null;

    // Icon CarOutlined Path
    const carPath = "M880 348H730l-10.4-38.6c-4.9-18.1-21.5-30.7-40.2-30.7H344.6c-18.7 0-35.3 12.5-40.2 30.7L294 348H144c-17.7 0-32 14.3-32 32v384c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V380c0-17.7-14.3-32-32-32zM363.6 348l13-48h270.8l13 48H363.6zM848 732H176V412h672v320zM304 528c0-35.3 28.7-64 64-64s64 28.7 64 64-28.7 64-64 64-64-28.7-64-64z m352 0c0-35.3 28.7-64 64-64s64 28.7 64 64-28.7 64-64 64-64-28.7-64-64z";

    // --- 1. E-RA INIT ---
    eraWidget.init({
        onConfiguration: (configs) => {
            configJSON = configs.realtime_configs[0]; // V20
            configBUTTON = configs.realtime_configs[1]; // V10

            // --- G·ªåI API L·∫§Y L·ªäCH S·ª¨ ---
            requestHistoryData();
        },
        
        // --- X·ª¨ L√ù D·ªÆ LI·ªÜU TH·ªúI GIAN TH·ª∞C ---
        onValues: (values) => {
            if (configJSON && values[configJSON.id]) {
                parseData(values[configJSON.id].value);
            }
            if (configBUTTON && values[configBUTTON.id]) {
                BUTTON = parseInt(values[configBUTTON.id].value);
            }
        },

        // --- X·ª¨ L√ù D·ªÆ LI·ªÜU L·ªäCH S·ª¨ (QUAN TR·ªåNG) ---
        onHistories: (history) => {
            // history[0] t∆∞∆°ng ·ª©ng v·ªõi configJSON (V20)
            if (!isHistoryLoaded && history && history[0] && history[0].data.length > 0) {
                console.log("ƒê√£ nh·∫≠n d·ªØ li·ªáu l·ªãch s·ª≠:", history[0].data.length, "ƒëi·ªÉm");
                processHistoryData(history[0].data);
                isHistoryLoaded = true;
            }
        }
    });

    // --- 2. H√ÄM X·ª¨ L√ù L·ªäCH S·ª¨ ---
    function requestHistoryData() {
        const endTime = Date.now();
        const startTime = endTime - (HISTORY_HOURS * 60 * 60 * 1000);
        eraWidget.requestHistories(startTime, endTime);
    }

    function processHistoryData(dataArray) {
        // dataArray c√≥ d·∫°ng: [[timestamp, value], [timestamp, value], ...]
        let historyPoints = [];
        let lastValidData = null;

        dataArray.forEach(item => {
            try {
                // item[1] l√† gi√° tr·ªã chu·ªói JSON
                const rawJson = item[1];
                const d = JSON.parse(rawJson);
                
                if (d.lat && d.lon && d.lat !== 0 && d.lon !== 0) {
                    const pt = [parseFloat(d.lat), parseFloat(d.lon)];
                    historyPoints.push(pt);
                    lastValidData = d; // L∆∞u l·∫°i ƒëi·ªÉm cu·ªëi c√πng ƒë·ªÉ update tr·∫°ng th√°i hi·ªán t·∫°i
                }
            } catch (e) { /* B·ªè qua g√≥i tin l·ªói */ }
        });

        // V·∫Ω ƒë∆∞·ªùng l·ªãch s·ª≠ l√™n b·∫£n ƒë·ªì
        if (historyPoints.length > 0) {
            // X√≥a ƒë∆∞·ªùng c≈© n·∫øu c√≥
            if (currentPath) map.removeLayer(currentPath);

            // V·∫Ω Polyline m√†u x√°m ƒë·∫≠m cho l·ªãch s·ª≠
            currentPath = L.polyline(historyPoints, {
                color: '#555', // M√†u ƒë∆∞·ªùng l·ªãch s·ª≠
                weight: 4,
                opacity: 0.7,
                dashArray: '5, 10', // N√©t ƒë·ª©t ƒë·ªÉ ph√¢n bi·ªát v·ªõi realtime
                lineCap: 'round'
            }).addTo(map);

            // L∆∞u v√†o bi·∫øn to√†n c·ª•c ƒë·ªÉ v·∫Ω ti·∫øp realtime
            pathCoordinates = historyPoints;
            lastPosition = historyPoints[historyPoints.length - 1];

            // Di chuy·ªÉn Marker ƒë·∫øn v·ªã tr√≠ cu·ªëi c√πng
            marker.setLatLng(lastPosition);
            
            // Zoom b·∫£n ƒë·ªì ƒë·ªÉ th·∫•y to√†n b·ªô h√†nh tr√¨nh
            map.fitBounds(currentPath.getBounds());

            // C·∫≠p nh·∫≠t th√¥ng s·ªë hi·ªán t·∫°i theo ƒëi·ªÉm cu·ªëi c√πng
            if (lastValidData) {
                LAT = parseFloat(lastValidData.lat);
                LON = parseFloat(lastValidData.lon);
                SPEED = parseFloat(lastValidData.spd || 0);
                ALT = parseFloat(lastValidData.alt || 0);
                TEMP = parseFloat(lastValidData.temp || 0);
                SATS = parseInt(lastValidData.sat || 0);
                updateInfoBox();
            }
        }
    }

    // --- 3. H√ÄM PARSE DATA REALTIME ---
    function parseData(rawString) {
        try {
            const data = JSON.parse(rawString);
            if (data.lat !== undefined) LAT = parseFloat(data.lat);
            if (data.lon !== undefined) LON = parseFloat(data.lon);
            if (data.alt !== undefined) ALT = parseFloat(data.alt);
            if (data.spd !== undefined) SPEED = parseFloat(data.spd);
            if (data.temp !== undefined) TEMP = parseFloat(data.temp);
            if (data.sat !== undefined) SATS = parseInt(data.sat);
            updateInfoBox();
        } catch (e) {}
    }

    // --- 4. MAP INIT ---
    window.onload = function() { initMap(); }

    function initMap() {
        const startLat = 10.762622;
        const startLng = 106.660172;
        map = L.map('map').setView([startLat, startLng], 15);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19, attribution: '¬© OpenStreetMap'
        }).addTo(map);

        marker = L.marker([startLat, startLng], { icon: createCarIcon() }).addTo(map);
        createInfoControl();
        
        // Loop Realtime Update
        setInterval(updateMapCenter, 1000);
    }

    function createCarIcon() {
        const color = "#1890ff"; 
        const svgHtml = `<svg viewBox="0 0 1024 1024" width="48" height="48" xmlns="http://www.w3.org/2000/svg"><path d="${carPath}" fill="${color}" stroke="white" stroke-width="20"></path></svg>`;
        return L.divIcon({ className: 'custom-div-icon', html: `<div class="marker-pin">${svgHtml}</div>`, iconSize: [48, 48], iconAnchor: [24, 24], popupAnchor: [0, -24] });
    }

    // --- 5. MAP UPDATE REALTIME ---
    function updateMapCenter() {
        if (LAT && LON && LAT !== 0) {
            const newLatLng = [LAT, LON];
            
            // Marker di chuy·ªÉn m∆∞·ª£t m√†
            marker.setLatLng(newLatLng);
            
            // Ch·ªâ pan map n·∫øu marker ƒëi ra kh·ªèi v√πng nh√¨n th·∫•y (UX t·ªët h∆°n)
            if (!map.getBounds().contains(newLatLng)) {
                map.panTo(newLatLng);
            }

            // Popup
            const popupContent = `<div style="text-align:center; padding:5px;"><div style="font-size:11px; color:#888; text-transform:uppercase;">Nhi·ªát ƒë·ªô</div><div style="font-size:26px; font-weight:bold; color:#ff4d4f;">${TEMP.toFixed(1)}¬∞C</div></div>`;
            if (marker.getPopup() && marker.getPopup().isOpen()) marker.getPopup().setContent(popupContent);
            else marker.bindPopup(popupContent);

            // V·∫Ω ƒë∆∞·ªùng Realtime (N·ªëi ti·∫øp l·ªãch s·ª≠)
            // Logic: N·∫øu ƒëang c√≥ ƒë∆∞·ªùng l·ªãch s·ª≠ (m√†u x√°m), ta v·∫Ω ti·∫øp ƒë∆∞·ªùng realtime (m√†u gradient)
            if (BUTTON === 1) {
                const strokeColor = getGradientColor(SPEED);
                
                // N·∫øu ch∆∞a c√≥ path n√†o ho·∫∑c m√†u thay ƒë·ªïi -> t·∫°o segment m·ªõi
                if (!currentPath || (currentPath.options.color !== strokeColor && currentPath.options.color !== '#555')) {
                    // N·∫øu pathCoordinates c√≥ d·ªØ li·ªáu (t·ª´ l·ªãch s·ª≠ ho·∫∑c segment tr∆∞·ªõc), l·∫•y ƒëi·ªÉm cu·ªëi l√†m ƒëi·ªÉm ƒë·∫ßu segment m·ªõi
                    const startPoints = pathCoordinates.length > 0 ? [pathCoordinates[pathCoordinates.length - 1]] : [];
                    
                    // T·∫°o ƒë∆∞·ªùng m·ªõi ƒë√® l√™n
                    currentPath = L.polyline(startPoints, {
                        color: strokeColor, weight: 6, opacity: 0.9, lineCap: 'round'
                    }).addTo(map);
                }
                
                // Th√™m ƒëi·ªÉm m·ªõi v√†o path hi·ªán t·∫°i
                currentPath.addLatLng(newLatLng);
                
                // C·∫≠p nh·∫≠t m·∫£ng t·ªïng
                pathCoordinates.push(newLatLng);
                lastPosition = newLatLng;
            }
        }
    }

    // --- 6. UTILS ---
    function createInfoControl() {
        infoControl = L.control({position: 'topright'});
        infoControl.onAdd = function() { this._div = L.DomUtil.create('div', 'info-box'); this.update(); return this._div; };
        infoControl.update = function() {
            const speedColor = getGradientColor(SPEED);
            this._div.innerHTML = `
                <div class="info-title">üöÄ GPS MONITOR</div>
                <div class="info-item"><span>Speed:</span> <span class="info-value" style="color:${speedColor}; font-size:18px;">${SPEED.toFixed(1)} km/h</span></div>
                <div class="info-item"><span>Altitude:</span> <span class="info-value">${ALT.toFixed(1)} m</span></div>
                <div class="info-item"><span>Satellites:</span> <span class="info-value">${SATS}</span></div>
                <div class="info-footer">Lat: ${LAT.toFixed(6)} <br> Lon: ${LON.toFixed(6)}</div>
            `;
        };
        infoControl.addTo(map);
    }
    function updateInfoBox() { if (infoControl) infoControl.update(); }

    function getGradientColor(speed) {
        const stops = [{s:0,c:[0,0,255]},{s:40,c:[0,255,0]},{s:70,c:[255,165,0]},{s:100,c:[255,0,0]},{s:120,c:[148,0,211]}];
        if (speed <= 0) return `rgb(${stops[0].c})`; if (speed >= 120) return `rgb(${stops[4].c})`;
        for (let i=0; i<stops.length-1; i++) {
            if (speed>=stops[i].s && speed<=stops[i+1].s) {
                let f=(speed-stops[i].s)/(stops[i+1].s-stops[i].s);
                let r=Math.round(stops[i].c[0]+f*(stops[i+1].c[0]-stops[i].c[0]));
                let g=Math.round(stops[i].c[1]+f*(stops[i+1].c[1]-stops[i].c[1]));
                let b=Math.round(stops[i].c[2]+f*(stops[i+1].c[2]-stops[i].c[2]));
                return `rgb(${r},${g},${b})`;
            }
        }
    }
</script>
</body>
</html>
